./actions/models.ts:
"use node";

import { action } from "convex/_generated/server";
import { load } from "js-yaml";
import fs from "fs";
import { v } from "convex/values";
import { requireAuth } from "convex/utils/helpers";
import { api } from "convex/_generated/api";

export type ModelList = {
  model_list: {
    model_name: string;
    litellm_params: {
      model: string;
      api_key?: string;
      tags?: string[];
    };
    api_key?: string;
    tags?: string[];
  }[];
};

export type GetModelResult = {
  config: ModelList;
  selectedModel: string;
};

export const getModel = action({
  args: {
    chatId: v.union(v.id("chats"), v.literal("new")),
  },
  handler: async (ctx, args): Promise<GetModelResult> => {
    await requireAuth(ctx);

    const chatInput = await ctx.runQuery(api.routes.chatInput.get, {
      chatId: args.chatId,
    });

    if (!chatInput) {
      throw new Error("Chat input not found");
    }

    let selectedModel = chatInput.model;

    const config = load(
      fs.readFileSync("./litellm_config.yaml", "utf8"),
    ) as ModelList;
    const defaultModel = config.model_list[0].model_name;

    if (!selectedModel) {
      selectedModel = defaultModel;
    }

    return {
      config,
      selectedModel,
    };
  },
});

./actions/projectDocuments.ts:
"use node";

import { action } from "../_generated/server";
import { v } from "convex/values";
import { api } from "../_generated/api";
import type { Id } from "../_generated/dataModel";
import { Document } from "langchain/document";
import { getTextSplitter, getVectorStore } from "../langchain/weaviate";
import { YoutubeLoader } from "@langchain/community/document_loaders/web/youtube";

function formatDocUrl(docUrl: string) {
  const url = new URL(docUrl);
  url.host = "backend:3210";
  return url.toString();
}

export const add = action({
  args: {
    documentId: v.id("documents"),
    projectId: v.id("projects"),
  },
  handler: async (ctx, args): Promise<Id<"projectDocuments">> => {
    // First get the document from storage
    const storageDoc = await ctx.runQuery(api.routes.documents.get, {
      documentId: args.documentId,
    });

    // Process document through docling API
    let docUrl: string = "";
    try {
      docUrl = formatDocUrl(
        (await ctx.storage.getUrl(storageDoc.key as Id<"_storage">)) ?? "",
      );
    } catch (error) {
      docUrl = storageDoc.key ?? "";
    }

    let pageContent = "";
    if (storageDoc.type === "file") {
      pageContent = await fetch(
        "http://services:5001/convert/?source=" + docUrl,
        {
          headers: {
            Authorization: `Bearer ${process.env.SERVICE_PASS}`,
          },
        },
      ).then(async (res) => await res.text());
    } else if (storageDoc.type === "url") {
      const res = await fetch(
        "http://services:5002/crawl/?url=" + encodeURIComponent(docUrl) + "&max_depth=0",
      );
      const data = (await res.json()) as { url: string; markdown: string };
      pageContent = `# ${data.url}\n\n${data.markdown}`;
    } else if (storageDoc.type === "youtube") {
      const loader = YoutubeLoader.createFromUrl(docUrl, {
        language: "en",
        addVideoInfo: true,
      });
      const docs = await loader.load();
      pageContent = docs.map((doc) => doc.pageContent).join("\n\n");
    } else if (storageDoc.type === "site") {
      const res = await fetch(
        "http://services:5002/crawl/?url=" + encodeURIComponent(docUrl) + "&max_depth=2",
      );
      const data = (await res.json()) as { url: string; markdown: string }[];
      pageContent = data
        .map((data) => `# ${data.url}\n\n${data.markdown}`)
        .join("\n\n");
    }

    if (!pageContent) {
      throw new Error("Failed to process document with Docling");
    }

    // Split text into chunks
    const docs = await getTextSplitter().splitDocuments([
      new Document({
        pageContent: pageContent,
        metadata: {
          source: storageDoc._id,
          projectId: args.projectId,
        },
      }),
    ]);

    // Add documents to vector store
    try {
      await getVectorStore().addDocuments(docs);
    } catch (error) {
      throw new Error("Failed to add document to vector store:\n" + error);
    }

    // Create project document in database
    const projectDocument = await ctx.runMutation(
      api.routes.projectDocuments.create,
      {
        projectId: args.projectId,
        documentId: storageDoc._id,
      },
    );

    return projectDocument;
  },
});

export const remove = action({
  args: {
    projectDocumentId: v.id("projectDocuments"),
  },
  handler: async (ctx, args) => {
    // Get project document
    const projectDocument = await ctx.runQuery(
      api.routes.projectDocuments.get,
      {
        projectDocumentId: args.projectDocumentId,
      },
    );

    // Delete from vector store
    await getVectorStore().delete({
      filter: {
        where: {
          operator: "Equal" as const,
          path: ["source"],
          valueText: projectDocument.documentId,
        },
      },
    });

    // Delete from database
    await ctx.runMutation(api.routes.projectDocuments.remove, {
      projectDocumentId: args.projectDocumentId,
    });

    return true;
  },
});

./actions/mcps.ts:
"use node";

import { api } from "convex/_generated/api";
import { action } from "../_generated/server";
import { v } from "convex/values";
import Dockerode from "dockerode";
import { requireAuth } from "convex/utils/helpers";
import type { Id } from "convex/_generated/dataModel";

const docker = new Dockerode();

export const start = action({
  args: {
    mcpId: v.id("mcps"),
  },
  handler: async (ctx, args) => {
    await requireAuth(ctx);

    const mcp = await ctx.runQuery(api.routes.mcps.get, {
      mcpId: args.mcpId,
    });
    if (!mcp) {
      throw new Error("MCP not found");
    }
    if (!mcp.command) {
      throw new Error("MCP command not found");
    }

    const containers = await docker.listContainers({ all: true }); // Include stopped containers
    let container = containers.find((c) =>
      c.Names.some((name) => name === `/${mcp._id}` || name === mcp._id),
    );

    let sseUrl = mcp.url;
    if (container && container.State === "running") {
      // Container exists and is running, just update URL
      const ci = await docker.getContainer(container.Id).inspect();
      sseUrl = `http://localhost:${ci.HostConfig.PortBindings["8000/tcp"][0].HostPort}/sse`;
    }
    if (!sseUrl) {
      // Create a new container
      const newContainer = await docker.createContainer({
        name: mcp._id,
        Image: "mantrakp04/mcprunner:latest",
        Env: [
          `MCP_COMMAND=${mcp.command}`,
          ...(mcp.env
            ? Object.entries(mcp.env).map(([key, value]) => `${key}=${value}`)
            : []),
        ],
        HostConfig: {
          PortBindings: {
            "8000/tcp": [{ HostPort: "8000" }],
          },
        },
      });
      await newContainer.start();
      const ci = await newContainer.inspect();
      sseUrl = `http://${mcp._id}:${ci.HostConfig.PortBindings["8000/tcp"][0].HostPort}/sse`;
    }

    await ctx.runMutation(api.routes.mcps.update, {
      mcpId: args.mcpId,
      updates: sseUrl
        ? {
            url: sseUrl,
            status: "running",
          }
        : {
            status: "error",
          },
    });
  },
});

export const stop = action({
  args: {
    mcpId: v.id("mcps"),
  },
  handler: async (ctx, args) => {
    await requireAuth(ctx);

    const mcp = await ctx.runQuery(api.routes.mcps.get, {
      mcpId: args.mcpId,
    });
    if (!mcp) {
      throw new Error("MCP not found");
    }

    const containers = await docker.listContainers({ all: true }); // Include stopped containers
    const container = containers.find((c) =>
      c.Names.some((name) => name === `/${mcp._id}` || name === mcp._id),
    );

    if (!container) {
      await ctx.runMutation(api.routes.mcps.update, {
        mcpId: args.mcpId,
        updates: {
          status: "stopped",
          url: "",
        },
      });
      return;
    }

    try {
      const containerInstance = docker.getContainer(container.Id);
      // Force remove the container instead of just stopping it
      await containerInstance.remove({ force: true });

      await ctx.runMutation(api.routes.mcps.update, {
        mcpId: args.mcpId,
        updates: {
          status: "stopped",
          url: "",
        },
      });
    } catch (error: any) {
      throw new Error(
        `Failed to stop container: ${error?.message || "Unknown error"}`,
      );
    }
  },
});

export const stopIdle = action({
  args: {},
  handler: async (ctx, args) => {
    const containers = await docker.listContainers();
    // Remove leading slash from container names and ensure they are valid MCP IDs
    const mcpIds = containers
      .map((c) => c.Names[0]?.replace(/^\//, ""))
      .filter((name): name is Id<"mcps"> => typeof name === "string");

    const mcps = await ctx.runQuery(api.routes.mcps.getMultiple, {
      mcpIds,
    });
    // idle mcps are mcps that are running but last updated more than 15 minutes ago
    const idleMcps = mcps.filter(
      (mcp) =>
        mcp.status === "running" && mcp.updatedAt < Date.now() - 15 * 60 * 1000,
    );

    // Stop mcps
    await Promise.all(
      idleMcps.map((mcp) =>
        ctx.runAction(api.actions.mcps.stop, {
          mcpId: mcp._id,
        }),
      ),
    );
  },
});

./actions/chat.ts:
"use node";

import { v } from "convex/values";
import { action, internalAction } from "../_generated/server";
import { api } from "convex/_generated/api";
import { HumanMessage } from "@langchain/core/messages";
import { agentGraph } from "../langchain/agent";
import mime from "mime";
import type { Doc, Id } from "../_generated/dataModel";
import { Document } from "langchain/document";
import type { StreamEvent } from "@langchain/core/tracers/log_stream";
import { requireAuth } from "../utils/helpers";

function isMimeTypeSupported(mimeType: string, tags: string[]) {
  const mimeToTag: Record<string, string> = {
    "text/": "text",
    "image/": "image",
    "audio/": "audio",
    "video/": "video",
    "application/pdf": "pdf",
  };

  for (const [mimePrefix, tag] of Object.entries(mimeToTag)) {
    if (mimeType.startsWith(mimePrefix) && tags.includes(tag)) {
      return true;
    }
  }
  return false;
}

export const chat = internalAction({
  args: {
    chatId: v.id("chats"),
  },
  handler: async function* (
    ctx,
    args,
  ): AsyncGenerator<StreamEvent, void, unknown> {
    await ctx.runQuery(api.routes.chats.get, {
      chatId: args.chatId,
    });
    throw new Error("hi")
    const chatInput = await ctx.runQuery(api.routes.chatInput.get, {
      chatId: args.chatId,
    });
    const modelResult = await ctx.runAction(api.actions.models.getModel, {
      chatId: args.chatId,
    });
    const selectedModel = modelResult.config.model_list.find(
      (model) => model.model_name === modelResult.selectedModel,
    );


    if (!selectedModel) {
      throw new Error("Selected model not found");
    }

    const unsupportedDocuments: (Doc<"documents"> & { mimeType: string })[] =
      [];
    const documents = await ctx
      .runQuery(api.routes.documents.getMultiple, {
        documentIds: chatInput.documents ?? [],
      })
      .then((documents) => {
        return documents
          .map((document) => {
            const mimeType =
              mime.getType(document.name) ?? "application/octet-stream";
            return {
              ...document,
              mimeType,
            };
          })
          .filter((document) => {
            if (
              isMimeTypeSupported(document.mimeType, selectedModel?.tags ?? [])
            ) {
              return true;
            }
            unsupportedDocuments.push(document);
            return false;
          });
      });

    let additionalDocuments: Document[] = [];
    if (unsupportedDocuments.length > 0) {
      for (const document of unsupportedDocuments) {
        try {
          const docUrl = new URL(
            (await ctx.storage.getUrl(document.key as Id<"_storage">)) ?? "",
          );
          docUrl.host = "backend:3210";
          const pageContent = await fetch(
            "http://services:5001/convert/?source=" + new URL(docUrl),
            {
              headers: {
                Authorization: `Bearer ${process.env.SERVICE_PASS}`,
              },
            },
          ).then(async (res) => await res.text());
          additionalDocuments.push(
            new Document({
              pageContent: pageContent,
              metadata: {
                source: document.name,
                url:
                  (await ctx.storage.getUrl(document.key as Id<"_storage">)) ??
                  "",
              },
            }),
          );
        } catch (error) {
          // remove document from chat input
          await ctx.runMutation(api.routes.chatInput.update, {
            chatId: args.chatId,
            updates: {
              documents:
                chatInput.documents?.filter((id) => id !== document._id) ?? [],
            },
          });
          continue;
        }
      }
    }

    const humanMessage = new HumanMessage({
      content: [
        {
          type: "text",
          text: chatInput.text ?? "",
        },
        ...documents.map(async (document) => {
          const blob = (await ctx.storage.get(document.key)) as Blob;
          const arrayBuffer = await blob.arrayBuffer();
          const base64String = Buffer.from(arrayBuffer).toString("base64");
          return {
            type: "image_url",
            image_url: {
              url: `data:${document.mimeType};base64,${base64String}`,
            },
          };
        }),
        ...additionalDocuments.map(async (document) => {
          return {
            type: "text",
            text: `# [${document.metadata.source}](${document.metadata.url})\n\n${document.pageContent}`,
          };
        }),
      ],
    });
    const response = await agentGraph.streamEvents(
      {
        messages: [humanMessage],
      },
      {
        version: "v2",
        configurable: {
          ctx,
          model: selectedModel?.litellm_params.model ?? "",
          agentMode: chatInput.agentMode ?? false,
          smortMode: chatInput.smortMode ?? false,
          webSearch: chatInput.webSearch ?? true,
          projectId: chatInput.projectId,
          excludeDocumentIds: chatInput.documents ?? [],
          threadId: args.chatId,
        },
      },
    );

    for await (const event of response) {
      yield event;
    }
  },
});

export const messages = action({
  args: {
    chatId: v.id("chats"),
    replay: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    await requireAuth(ctx);

    const chat = await ctx.runQuery(api.routes.chats.get, {
      chatId: args.chatId,
    });
    if (!chat) {
      throw new Error("Chat not found");
    }

    if (args.replay) {
      const state = await agentGraph.getStateHistory({
        configurable: {
          threadId: args.chatId,
        },
      });
      return state;
    }

    const state = await agentGraph.getState({
      configurable: {
        threadId: args.chatId,
      },
    });
    return state;
  },
});

./utils/helpers.ts:
import { PersistentTextStreaming } from "@convex-dev/persistent-text-streaming";
import { components } from "convex/_generated/api";
import type { Id } from "convex/_generated/dataModel";
import {
  type QueryCtx,
  type MutationCtx,
  type ActionCtx,
} from "convex/_generated/server.js";
import { ConvexError } from "convex/values";

export async function requireAuth(ctx: QueryCtx | MutationCtx | ActionCtx) {
  const user = await ctx.auth.getUserIdentity();
  if (!user) {
    throw new ConvexError("Unauthorized");
  }
  const userId = user.subject.split("|")[0] as Id<"users">;
  return { user, userId };
}

export const persistentTextStreaming = new PersistentTextStreaming(
  components.persistentTextStreaming,
);

./http/chat.ts:
import { internal } from "../_generated/api";
import { persistentTextStreaming } from "../utils/helpers";
import { httpAction } from "../_generated/server";
import type { StreamId } from "@convex-dev/persistent-text-streaming";
import type { Id } from "convex/_generated/dataModel";

export const chat = httpAction(async (ctx, request) => {
  const body = (await request.json()) as {
    streamId: string;
  };
  const response = await persistentTextStreaming.stream(
    ctx,
    request,
    body.streamId as StreamId,
    async (ctx, _, streamId, chunkAppender) => {
      const { chatInput } = await ctx.runQuery(
        internal.routes.chatInput.getByStreamId,
        {
          streamId: streamId,
        },
      );

      const stream = await ctx.runAction(internal.actions.chat.chat, {
        chatId: chatInput.chatId as Id<"chats">,
      });

      for await (const event of stream) {
        chunkAppender(JSON.stringify(event));
      }
    },
  );

  response.headers.set("Access-Control-Allow-Origin", "*");
  response.headers.set("Vary", "Origin");
  return response;
});

./langchain/models.ts:
"use node";

import { ChatOpenAI, OpenAIEmbeddings } from "@langchain/openai";

export const getEmbeddings = () =>
  new OpenAIEmbeddings({
    model: "embedding",
    apiKey: "hello-world",
    configuration: {
      baseURL: "http://litellm:4000",
    },
  });

export const getModel = (model: string = "gemini-2.5-flash") =>
  new ChatOpenAI({
    model,
    apiKey: "hello-world",
    configuration: {
      baseURL: "http://litellm:4000",
    },
  });

./langchain/get_serch_tool.ts:
"use node";

import { TavilySearch } from "@langchain/tavily";
import { DuckDuckGoSearch } from "@langchain/community/tools/duckduckgo_search";
import { DynamicStructuredTool } from "@langchain/core/tools";
import { z } from "zod";

export const getSearchTools = () => {
  const tools: {
    tavily?: TavilySearch;
    duckduckgo: DuckDuckGoSearch;
    crawlWeb: DynamicStructuredTool;
  } = {
    duckduckgo: new DuckDuckGoSearch({ maxResults: 5 }),
    crawlWeb: new DynamicStructuredTool({
      name: "crawlWeb",
      description: "Crawl the web and return the markdown",
      schema: z.object({
        url: z.string().describe("The url to crawl"),
      }),
      func: async ({ url }: { url: string }) => {
        const response = await fetch(
          `http://localhost:5002/crawl/?url=${encodeURIComponent(url)}&max_depth=0`,
        );
        const data = await response.json();
        return data.markdown as string;
      },
    }),
  };

  if (process.env.TAVILY_API_KEY) {
    tools.tavily = new TavilySearch({
      maxResults: 5,
      topic: "general",
      tavilyApiKey: process.env.TAVILY_API_KEY,
    });
  }

  return tools;
};

./langchain/get_mcp_tools.ts:
"use node";

import { MultiServerMCPClient, type Connection } from "@langchain/mcp-adapters";
import { api } from "../_generated/api";
import type { ActionCtx } from "convex/_generated/server";
import type { StructuredToolInterface } from "@langchain/core/tools";
import type { ToolInputSchemaBase } from "node_modules/@langchain/core/dist/tools/types";

export const getMCPTools = async (ctx: ActionCtx) => {
  const mcps = await ctx.runQuery(api.routes.mcps.getAll, {
    paginationOpts: { numItems: 100, cursor: null },
    filter: {
      status: "running",
    },
  });

  // Start/Run & connect to enabled mcps
  await Promise.all(
    mcps.page.map((mcp) => {
      return ctx.runAction(api.actions.mcps.start, {
        mcpId: mcp._id,
      });
    }),
  );

  const mcpServers: Record<string, Connection> = Object.fromEntries(
    mcps.page
      .filter((mcp) => mcp.url !== undefined)
      .map((mcp) => [
        mcp.name,
        {
          transport: "sse",
          url: mcp.url!,
          headers: mcp.env,
          useNodeEventSource: true,
          reconnect: {
            enabled: true,
            maxAttempts: 2,
            delayMs: 100,
          },
        },
      ]),
  );

  const client = new MultiServerMCPClient({
    throwOnLoadError: true,
    prefixToolNameWithServerName: true,
    additionalToolNamePrefix: "mcp",
    mcpServers,
  });

  const tools = await client.getTools();

  // Group tools by server name
  const groupedTools: Record<
    string,
    StructuredToolInterface<ToolInputSchemaBase>[]
  > = {};

  for (const tool of tools) {
    // Tool names are prefixed with "mcp_serverName_" due to client configuration
    const parts = tool.name.split("_");
    if (parts.length >= 2) {
      // Skip the "mcp" prefix and get the server name
      const serverName = parts[1];
      if (!groupedTools[serverName]) {
        groupedTools[serverName] = [];
      }
      groupedTools[serverName].push(tool);
    }
  }

  return {
    tools,
    groupedTools,
  };
};

./langchain/agent.ts:
"use node";

import { getModel } from "./models";
import {
  Annotation,
  END,
  messagesStateReducer,
  START,
  StateGraph,
} from "@langchain/langgraph";
import type { DocumentInterface } from "@langchain/core/documents";
import type { RunnableConfig } from "@langchain/core/runnables";
import type { ActionCtx } from "convex/_generated/server";
import {
  BaseMessage,
  SystemMessage,
  HumanMessage,
} from "@langchain/core/messages";
import {
  ChatPromptTemplate,
  MessagesPlaceholder,
} from "@langchain/core/prompts";
import { z } from "zod";
import type { Id } from "convex/_generated/dataModel";
import { api } from "convex/_generated/api";
import { Document } from "langchain/document";
import { getVectorStore } from "./weaviate";
import type { TavilySearchResponse } from "@langchain/tavily";
import { formatDocumentsAsString } from "langchain/util/document";
import { getSearchTools } from "./get_serch_tool";
import { getMCPTools } from "./get_mcp_tools";
import { createSupervisor } from "@langchain/langgraph-supervisor";
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { AIMessage } from "@langchain/core/messages";
import { PostgresSaver } from "@langchain/langgraph-checkpoint-postgres";

const checkpointer = PostgresSaver.fromConnString(
  "postgresql://postgres:postgres@database:5432",
);
await checkpointer.setup();

// Extend RunnableConfig to include ctx
type ExtendedRunnableConfig = RunnableConfig & {
  ctx: ActionCtx;
  model: string;
  agentMode: boolean;
  smortMode: boolean;
  webSearch: boolean;
  projectId?: Id<"projects">;
  excludeDocumentIds?: Id<"projectDocuments">[];
};

const plan = z
  .array(
    z.object({
      step: z.string().describe("The step to be executed"),
      additional_context: z
        .string()
        .describe("Additional context that may be needed to execute the step"),
    }),
  )
  .describe("A step by step plan to achieve the objective")
  .min(1)
  .max(7);

// Represents the state of our graph.
const GraphState = Annotation.Root({
  messages: Annotation<BaseMessage[]>({
    reducer: messagesStateReducer,
    default: () => [],
  }),
  documents: Annotation<DocumentInterface[]>({
    reducer: (x, y) => y ?? x ?? [],
  }),
  lastNode: Annotation<Record<string, any>>({
    reducer: (x, y) => y ?? x ?? {},
  }),
  smortPlan: Annotation<z.infer<typeof plan>>({
    reducer: (x, y) => y ?? x ?? [],
  }),
});

async function generateQuery(
  state: typeof GraphState.State,
  config: ExtendedRunnableConfig,
) {
  const promptTemplate = ChatPromptTemplate.fromMessages([
    [
      "system",
      "Determine if the user needs queries for VectorStore, WebSearch, or both. Generate relevant queries.",
    ],
    [
      "human",
      "Give queries for the following: " +
        (config.webSearch ? "WebSearch" : "") +
        (config.projectId ? "VectorStore" : "") +
        ".",
    ],
    new MessagesPlaceholder("messages"),
  ]);
  const modelWithOutputParser = promptTemplate.pipe(
    getModel(config.model).withStructuredOutput(
      z.object({
        vectorStoreQueries: z.optional(
          z
            .array(z.string())
            .describe("Queries for the vector database")
            .max(3)
            .min(1),
        ),
        webSearchQueries: z.optional(
          z.array(z.string()).describe("Queries for web search").max(3).min(1),
        ),
      }),
    ),
  );

  const queries = await modelWithOutputParser.invoke({
    messages: state.messages.slice(-5),
  });
  return {
    lastNode: queries,
  };
}

async function retrieve(
  state: typeof GraphState.State,
  config: ExtendedRunnableConfig,
) {
  const docNodeMap = new Map<string, DocumentInterface[]>();
  if (config.projectId && state.lastNode.vectorStoreQueries) {
    const vectorStore = getVectorStore();
    const excludedProjectDocuments = await config.ctx.runQuery(
      api.routes.projectDocuments.getMultiple,
      {
        projectDocumentIds: config.excludeDocumentIds ?? [],
      },
    );

    await Promise.all(
      state.lastNode.vectorStoreQueries.map(async (node: string) => {
        const docs = await vectorStore.similaritySearch(node, 3, {
          where: {
            operator: "And" as const,
            operands: [
              {
                operator: "Equal" as const,
                path: ["projectId"],
                valueText: config.projectId,
              },
              ...excludedProjectDocuments.map((doc) => ({
                operator: "NotEqual" as const,
                path: ["source"],
                valueText: doc.documentId,
              })),
            ],
          },
        });
        docNodeMap.set(node, docs);
      }),
    );
    return {
      documents: docNodeMap,
    };
  }
  if (config.webSearch && state.lastNode.webSearchQueries) {
    const searchTools = getSearchTools();
    await Promise.all(
      state.lastNode.webSearchQueries.map(async (node: string) => {
        if (searchTools.tavily) {
          const searchResults = (await searchTools.tavily._call({
            query: node,
            topic: "general",
            includeImages: false,
            includeDomains: [],
            excludeDomains: [],
            searchDepth: "basic",
          })) as TavilySearchResponse;
          docNodeMap.set(
            node,
            searchResults.results.map((result) => {
              return new Document({
                pageContent: `${result.score}. ${result.title}\n${result.url}\n${result.content}`,
                metadata: {
                  source: "tavily",
                },
              });
            }),
          );
        } else {
          const searchResults = await searchTools.duckduckgo._call(node);
          const searchResultsArray: {
            title: string;
            url: string;
            snippet: string;
          }[] = JSON.parse(searchResults);
          const urlMarkdownContents = await Promise.all(
            searchResultsArray.map(
              (result) =>
                searchTools.crawlWeb.func({
                  url: result.url,
                }) as Promise<string>,
            ),
          );
          docNodeMap.set(
            node,
            searchResultsArray.map((result, index) => {
              return new Document({
                pageContent: `${result.title}\n${result.url}\n${urlMarkdownContents[index]}`,
                metadata: {
                  source: "duckduckgo",
                },
              });
            }),
          );
        }
      }),
    );
    return {
      documents: docNodeMap,
    };
  }
  return { documents: docNodeMap };
}

async function gradeDocuments(
  state: typeof GraphState.State,
  config: ExtendedRunnableConfig,
) {
  const promptTemplate = ChatPromptTemplate.fromTemplate(
    `You are a grader assessing relevance of a retrieved document to a user question.
        Here is the retrieved document:

        {context}

        Here is the conversation history (focus on the last message as the question):
        {messages}

        If the document contains keyword(s) or semantic meaning related to the user question, grade it as relevant.
        Give a binary score 'yes' or 'no' score to indicate whether the document is relevant to the question.`,
  );

  const modelWithOutputParser = promptTemplate.pipe(
    getModel(config.model).withStructuredOutput(
      z
        .object({
          binaryScore: z
            .enum(["yes", "no"])
            .describe("Relevance score 'yes' or 'no'"),
        })
        .describe(
          "Grade the relevance of the retrieved documents to the question. Either 'yes' or 'no'.",
        ),
    ),
  );

  const relevantDocs: DocumentInterface[] = [];

  // Grade each document for relevance
  await Promise.all(
    state.documents.map(async (doc) => {
      const grade = await modelWithOutputParser.invoke({
        context: doc.pageContent,
        messages: state.messages.slice(-3),
      });

      if (grade.binaryScore === "yes") {
        relevantDocs.push(doc);
      }
    }),
  );

  return {
    documents: relevantDocs,
  };
}

async function shouldPlan(
  state: typeof GraphState.State,
  options: Record<string, any>,
) {
  const config = options as ExtendedRunnableConfig;
  return config.smortMode ? "true" : "false";
}

async function agent(
  state: typeof GraphState.State,
  config: ExtendedRunnableConfig,
) {
  const promptTemplate = ChatPromptTemplate.fromMessages([
    new SystemMessage(
      `You are 0bs Chat, an AI assistant powered by the ${config.model} model. ` +
        `Your role is to assist and engage in conversation while being helpful, respectful, and engaging.\n` +
        `- If you are specifically asked about the model you are using, you may mention that you use the ${config.model} model. If you are not asked specifically about the model you are using, you do not need to mention it.\n` +
        `- The current date and time is ${new Date().toLocaleString()}.\n` +
        `- Always use LaTeX for mathematical expressions.\n` +
        `   - Inline math must be wrapped in escaped parentheses: \( content \).\n` +
        `   - Do not use single dollar signs for inline math.\n` +
        `   - Display math must be wrapped in double dollar signs: $$ content $$.\n` +
        `- When generating code:\n` +
        `   - Ensure it is properly formatted using Prettier with a print width of 80 characters\n` +
        `   - Present it in Markdown code blocks with the correct language extension indicated\n`,
    ),
    ...(state.documents.length > 0
      ? [
          new HumanMessage(
            "Here are the documents that are relevant to the question: " +
              formatDocumentsAsString(state.documents),
          ),
        ]
      : []),
    new MessagesPlaceholder("messages"),
  ]);

  const tools = await getMCPTools(config.ctx);
  const searchTools = await getSearchTools();

  let agent;
  if (!config.agentMode) {
    agent = createReactAgent({
      llm: getModel(config.model),
      tools: [
        ...tools.tools,
        ...(searchTools.tavily ? [searchTools.tavily] : []),
        ...(searchTools.duckduckgo
          ? [searchTools.duckduckgo, searchTools.crawlWeb]
          : []),
      ],
      prompt: promptTemplate,
    });
  } else {
    // map tools.groupedTools to a list of createReactAgents with the same prompt
    // create a group of react agents with `You are a ${groupName} assistant` prompt
    const agents = Object.entries(tools.groupedTools).map(
      ([groupName, tools]) =>
        createReactAgent({
          llm: getModel(config.model),
          tools,
          prompt: new SystemMessage(`You are a ${groupName} assistant`),
        }),
    );

    agent = createSupervisor({
      agents,
      tools: [],
      llm: getModel(config.model),
      prompt:
        `You are 0bs Chat, an AI assistant powered by the ${config.model} model. ` +
        `Your role is to analyze the user's request and determine a plan of action to take. Assign each plan step to the appropriate agent, one at a time.\n`,
    }).compile();
  }

  const response = await agent.invoke(
    {
      messages: state.messages,
    },
    config,
  );

  const newMessages = response.messages.slice(
    state.messages.length,
    response.messages.length,
  );

  return {
    messages: newMessages,
  };
}

async function smortPlanner(
  state: typeof GraphState.State,
  config: ExtendedRunnableConfig,
) {
  const promptTemplate = ChatPromptTemplate.fromMessages([
    [
      "system",
      `For the given objective, come up with a simple step by step plan.\n` +
        `This plan should involve individual tasks, that if executed correctly will yield the correct answer. Do not add any superfluous steps.\n` +
        `The result of the final step should be the final answer. Make sure that each step has all the information needed - do not skip steps.\n`,
    ],
    new MessagesPlaceholder("messages"),
  ]);

  const modelWithOutputParser = promptTemplate.pipe(
    getModel(config.model).withStructuredOutput(plan),
  );

  const response = await modelWithOutputParser.invoke({
    messages: state.messages[state.messages.length - 1],
  });

  return {
    smortPlan: response,
  };
}

async function smortAgent(
  state: typeof GraphState.State,
  config: ExtendedRunnableConfig,
) {
  // If there's no plan or it's empty, return early
  if (!state.smortPlan || state.smortPlan.length === 0) {
    return {};
  }

  const currentTask = state.smortPlan[0];
  const remainingPlan = state.smortPlan.slice(1);

  const promptTemplate = ChatPromptTemplate.fromMessages([
    new SystemMessage(
      `You are 0bs Chat, an AI assistant powered by the ${config.model} model. ` +
        `Your role is to complete the following specific task:\n` +
        `${currentTask.step}\n\n` +
        `Additional Context: ${currentTask.additional_context}\n\n` +
        `- If you are specifically asked about the model you are using, you may mention that you use the ${config.model} model.\n` +
        `- The current date and time is ${new Date().toLocaleString()}.\n` +
        `- Always use LaTeX for mathematical expressions.\n` +
        `   - Inline math must be wrapped in escaped parentheses: \( content \).\n` +
        `   - Do not use single dollar signs for inline math.\n` +
        `   - Display math must be wrapped in double dollar signs: $$ content $$.\n` +
        `- When generating code:\n` +
        `   - Ensure it is properly formatted using Prettier with a print width of 80 characters\n` +
        `   - Present it in Markdown code blocks with the correct language extension indicated\n`,
    ),
    ...(state.documents.length > 0
      ? [
          new HumanMessage(
            "Here are the documents that are relevant to the question: " +
              formatDocumentsAsString(state.documents),
          ),
        ]
      : []),
    new MessagesPlaceholder("messages"),
  ]);

  const tools = await getMCPTools(config.ctx);
  const searchTools = await getSearchTools();

  let agent;
  if (!config.agentMode) {
    agent = createReactAgent({
      llm: getModel(config.model),
      tools: [
        ...tools.tools,
        ...(searchTools.tavily ? [searchTools.tavily] : []),
        ...(searchTools.duckduckgo
          ? [searchTools.duckduckgo, searchTools.crawlWeb]
          : []),
      ],
      prompt: promptTemplate,
    });
  } else {
    const agents = Object.entries(tools.groupedTools).map(
      ([groupName, tools]) =>
        createReactAgent({
          llm: getModel(config.model),
          tools,
          prompt: new SystemMessage(
            `You are a ${groupName} assistant focused on completing this task: ${currentTask.step}`,
          ),
        }),
    );

    agent = createSupervisor({
      agents,
      tools: [],
      llm: getModel(config.model),
      prompt:
        `You are 0bs Chat, an AI assistant powered by the ${config.model} model. ` +
        `Your role is to complete this specific task: ${currentTask.step}\n` +
        `Additional Context: ${currentTask.additional_context}\n`,
    }).compile();
  }

  const response = await agent.invoke(
    {
      messages: state.messages,
    },
    config,
  );

  const newMessages = response.messages.slice(-1).map((message) => {
    message.response_metadata["smortPlanSteps"] = currentTask;
    return message;
  });

  return {
    messages: newMessages,
    smortPlan: remainingPlan,
  };
}

async function smortReplan(
  state: typeof GraphState.State,
  config: ExtendedRunnableConfig,
) {
  const promptTemplate = ChatPromptTemplate.fromTemplate(
    `For the given objective, come up with a simple step by step plan. ` +
      `This plan should involve individual tasks that, if executed correctly, will yield the correct answer. Do not add any superfluous steps. ` +
      `The result of the final step should be the final answer. Make sure that each step has all the information needed - do not skip steps.\n\n` +
      `Your objective was this:` +
      new MessagesPlaceholder("input") +
      "\n\n" +
      `Your original plan was this:\n{plan}\n\n` +
      `You have currently done the following steps:\n{pastSteps}\n\n` +
      `Update your plan accordingly. If no more steps are needed and you can return to the user, then respond with that and use the 'response' function. ` +
      `Otherwise, fill out the plan. Only add steps to the plan that still NEED to be done. Do not return previously done steps as part of the plan.`,
  );

  const outputParser = z.union([
    plan,
    z.object({
      response: z.string().describe("The response to the user"),
    }),
  ]);

  const modelWithOutputParser = promptTemplate.pipe(
    getModel(config.model).withStructuredOutput(outputParser),
  );

  // Past steps are mapped as: `Step {index}: {step}\nAdditional Context: {additional_context}\nResponse: {content}`
  // Find messages with the response_metadata["smortPlanSteps"] and format them as above
  const pastSteps = state.messages
    .filter((message) => message.response_metadata["smortPlanSteps"])
    .map((message, index) => {
      return `Step ${index}: ${message.response_metadata["smortPlanSteps"].step}\nAdditional Context: ${message.response_metadata["smortPlanSteps"].additional_context}\nResponse: ${message.content}`;
    })
    .join("\n");

  const response = await modelWithOutputParser.invoke({
    input: state.messages[state.messages.length - 1],
    plan: state.smortPlan,
    pastSteps: pastSteps,
  });

  if (typeof response === "object" && "response" in response) {
    return {
      messages: [
        new AIMessage(response.response, {
          response_metadata: {
            smortPlanSteps: {
              step: "Response",
            },
          },
        }),
      ],
    };
  } else {
    return {
      smortPlan: response,
    };
  }
}

function smortShouldEnd(state: typeof GraphState.State) {
  const lastMessage = state.messages[state.messages.length - 1];
  if (lastMessage.response_metadata["smortPlanSteps"]?.step === "Response") {
    return "true";
  }
  return "false";
}

// Add these wrappers before the smortGraph definition
const wrapNodeFunction = <T extends Record<string, any>>(
  fn: (
    state: typeof GraphState.State,
    config: ExtendedRunnableConfig,
  ) => Promise<T>,
) => {
  return async (
    state: typeof GraphState.State,
    options: Record<string, any>,
  ) => {
    return fn(state, options as ExtendedRunnableConfig);
  };
};

export const agentGraph = new StateGraph(GraphState)
  .addNode("generateQuery", wrapNodeFunction(generateQuery))
  .addNode("retrieve", wrapNodeFunction(retrieve))
  .addNode("gradeDocuments", wrapNodeFunction(gradeDocuments))
  .addNode("agent", wrapNodeFunction(agent))
  .addNode("smortPlanner", wrapNodeFunction(smortPlanner))
  .addNode("smortAgent", wrapNodeFunction(smortAgent))
  .addNode("smortReplan", wrapNodeFunction(smortReplan))
  .addEdge(START, "generateQuery")
  .addEdge("generateQuery", "retrieve")
  .addEdge("retrieve", "gradeDocuments")
  .addConditionalEdges("gradeDocuments", shouldPlan, {
    true: "smortPlanner",
    false: "agent",
  })

  .addEdge("smortPlanner", "smortAgent")
  .addEdge("smortAgent", "smortReplan")
  .addConditionalEdges("smortReplan", smortShouldEnd, {
    true: END,
    false: "smortAgent",
  })

  .addEdge("agent", END)
  .compile({
    checkpointer: checkpointer,
  });

./langchain/weaviate.ts:
"use node";

import weaviate from "weaviate-ts-client";
import { WeaviateStore } from "@langchain/weaviate";
import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";
import { getEmbeddings } from "./models";

// Initialize text splitter for markdown
export const getTextSplitter = () =>
  RecursiveCharacterTextSplitter.fromLanguage("markdown", {
    chunkSize: 1000,
    chunkOverlap: 200,
  });

// Initialize Weaviate store
export const getVectorStore = () =>
  new WeaviateStore(getEmbeddings(), {
    client: weaviate.client({
      scheme: "http",
      host: "weaviate:8080",
    }),
    indexName: "ProjectDocuments",
    textKey: "text",
    metadataKeys: ["projectId", "source"],
  });

./routes/projectDocuments.ts:
import { query, mutation } from "../_generated/server";
import { v } from "convex/values";
import { requireAuth } from "../utils/helpers";
import { paginationOptsValidator } from "convex/server";
import { api } from "convex/_generated/api";
import type { Id, Doc } from "convex/_generated/dataModel";

export const get = query({
  args: {
    projectDocumentId: v.id("projectDocuments"),
  },
  handler: async (
    ctx,
    args,
  ): Promise<
    Doc<"projectDocuments"> & {
      project: Doc<"projects">;
      document: Doc<"documents">;
    }
  > => {
    await requireAuth(ctx);

    const projectDocument = await ctx.db.get(args.projectDocumentId);
    if (!projectDocument) {
      throw new Error("Project document not found");
    }

    const project = await ctx.runQuery(api.routes.projects.get, {
      projectId: projectDocument.projectId as Id<"projects">,
    });
    if (!project) {
      throw new Error("Project not found");
    }

    const document = await ctx.runQuery(api.routes.documents.get, {
      documentId: projectDocument.documentId as Id<"documents">,
    });
    if (!document) {
      throw new Error("Document not found");
    }

    return {
      ...projectDocument,
      project,
      document,
    };
  },
});

export const getAll = query({
  args: {
    projectId: v.id("projects"),
    paginationOpts: v.optional(paginationOptsValidator),
  },
  handler: async (
    ctx,
    args,
  ): Promise<{
    projectDocuments: (Doc<"projectDocuments"> & {
      document: Doc<"documents">;
    })[];
    project: Doc<"projects"> | null;
  }> => {
    await requireAuth(ctx);

    const project = await ctx.runQuery(api.routes.projects.get, {
      projectId: args.projectId,
    });
    if (!project) {
      throw new Error("Project not found");
    }

    const projectDocuments = await ctx.db
      .query("projectDocuments")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .order("desc")
      .paginate(args.paginationOpts ?? { numItems: 10, cursor: null });
    if (projectDocuments.page.length === 0) {
      return {
        projectDocuments: [],
        project: null,
      };
    }

    const documents = await ctx.runQuery(api.routes.documents.getMultiple, {
      documentIds: projectDocuments.page.map(
        (projectDocument) => projectDocument.documentId,
      ),
    });
    if (!documents) {
      throw new Error("Documents not found");
    }

    const projectDocumentsMap = new Map<
      Id<"projectDocuments">,
      Doc<"projectDocuments"> & { document: Doc<"documents"> }
    >();
    const documentMap = new Map<Id<"documents">, Doc<"documents">>();
    documents.forEach((document) => documentMap.set(document._id, document));

    projectDocuments.page.forEach((projectDocument) => {
      const document = documentMap.get(projectDocument.documentId);
      if (!document) {
        throw new Error("Document not found");
      }

      projectDocumentsMap.set(projectDocument._id, {
        ...projectDocument,
        document,
      });
    });

    return {
      projectDocuments: Array.from(projectDocumentsMap.values()),
      project,
    };
  },
});

export const getMultiple = query({
  args: {
    projectDocumentIds: v.array(v.id("projectDocuments")),
  },
  handler: async (
    ctx,
    args,
  ): Promise<
    (Doc<"projectDocuments"> & {
      project: Doc<"projects">;
      document: Doc<"documents">;
    })[]
  > => {
    await requireAuth(ctx);

    return await Promise.all(
      args.projectDocumentIds.map(async (projectDocumentId) => {
        const projectDocument = await ctx.runQuery(
          api.routes.projectDocuments.get,
          {
            projectDocumentId,
          },
        );
        if (!projectDocument) {
          throw new Error("Project document not found");
        }

        return projectDocument;
      }),
    );
  },
});

export const create = mutation({
  args: {
    projectId: v.id("projects"),
    documentId: v.id("documents"),
  },
  handler: async (ctx, args) => {
    await requireAuth(ctx);

    const project = await ctx.runQuery(api.routes.projects.get, {
      projectId: args.projectId,
    });
    if (!project) {
      throw new Error("Project not found");
    }

    const document = await ctx.runQuery(api.routes.documents.get, {
      documentId: args.documentId,
    });
    if (!document) {
      throw new Error("Document not found");
    }

    const projectDocument = await ctx.db.insert("projectDocuments", {
      projectId: args.projectId,
      documentId: args.documentId,
      selected: true,
      updatedAt: Date.now(),
    });

    return projectDocument;
  },
});

export const update = mutation({
  args: {
    projectDocumentId: v.id("projectDocuments"),
    update: v.object({
      selected: v.optional(v.boolean()),
    }),
  },
  handler: async (ctx, args) => {
    await requireAuth(ctx);

    const projectDocument = await ctx.runQuery(
      api.routes.projectDocuments.get,
      {
        projectDocumentId: args.projectDocumentId,
      },
    );
    if (!projectDocument) {
      throw new Error("Project document not found");
    }

    await ctx.db.patch(args.projectDocumentId, {
      ...args.update,
      updatedAt: Date.now(),
    });

    return true;
  },
});

export const remove = mutation({
  args: {
    projectDocumentId: v.id("projectDocuments"),
  },
  handler: async (ctx, args) => {
    await requireAuth(ctx);

    const projectDocument = await ctx.runQuery(
      api.routes.projectDocuments.get,
      {
        projectDocumentId: args.projectDocumentId,
      },
    );
    if (!projectDocument) {
      throw new Error("Project document not found");
    }

    await ctx.db.delete(args.projectDocumentId);
    return true;
  },
});

export const toggleSelect = mutation({
  args: {
    projectId: v.id("projects"),
    selected: v.boolean(),
  },
  handler: async (ctx, args) => {
    await requireAuth(ctx);

    const project = await ctx.runQuery(api.routes.projects.get, {
      projectId: args.projectId,
    });
    if (!project) {
      throw new Error("Project not found");
    }

    const projectDocuments = await ctx.db
      .query("projectDocuments")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .collect();

    await Promise.all(
      projectDocuments.map((projectDocument) =>
        ctx.runMutation(api.routes.projectDocuments.update, {
          projectDocumentId: projectDocument._id,
          update: { selected: args.selected },
        }),
      ),
    );

    return true;
  },
});

./routes/mcps.ts:
import { query, mutation } from "../_generated/server";
import { v } from "convex/values";
import { requireAuth } from "../utils/helpers";
import { paginationOptsValidator } from "convex/server";
import { api } from "convex/_generated/api";
import type { Doc } from "convex/_generated/dataModel";
import { crud } from "convex-helpers/server/crud";
import schema from "../schema.js";

export const {
  create: mcpCreate,
  read: mcpRead,
  update: mcpUpdate,
  destroy: mcpDestroy,
} = crud(schema, "mcps");

export const get = query({
  args: {
    mcpId: v.id("mcps"),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const mcp = await ctx.db
      .query("mcps")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("_id"), args.mcpId))
      .first();

    if (!mcp) {
      throw new Error("MCP not found");
    }

    return mcp;
  },
});

export const getAll = query({
  args: {
    paginationOpts: paginationOptsValidator,
    filter: v.optional(
      v.object({
        status: v.optional(
          v.union(
            v.literal("running"),
            v.literal("stopped"),
            v.literal("error"),
          ),
        ),
      }),
    ),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const mcps = await ctx.db
      .query("mcps")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) =>
        args.filter?.status
          ? q.eq(q.field("status"), args.filter.status)
          : q.eq(1, 1),
      )
      .paginate(args.paginationOpts);

    return mcps;
  },
});

export const getMultiple = query({
  args: {
    mcpIds: v.array(v.id("mcps")),
  },
  handler: async (ctx, args): Promise<Doc<"mcps">[]> => {
    await requireAuth(ctx);

    const mcps = await Promise.all(
      args.mcpIds.map(async (mcpId) => {
        const mcp = await ctx.runQuery(api.routes.mcps.get, {
          mcpId: mcpId,
        });
        if (!mcp) {
          throw new Error("MCP not found");
        }
        return mcp;
      }),
    );

    return mcps;
  },
});

export const create = mutation({
  args: {
    name: v.string(),
    command: v.optional(v.string()),
    env: v.optional(v.record(v.string(), v.string())),
    url: v.optional(v.string()),
    status: v.optional(
      v.union(v.literal("running"), v.literal("stopped"), v.literal("error")),
    ),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    if (!args.command && !args.url) {
      throw new Error("Command or URL is required");
    }

    const newMCPId = await ctx.db.insert("mcps", {
      name: args.name,
      command: args.command,
      env: args.env,
      url: args.url,
      status: args.status,
      userId: userId,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });

    return newMCPId;
  },
});

export const update = mutation({
  args: {
    mcpId: v.id("mcps"),
    updates: v.object({
      name: v.optional(v.string()),
      command: v.optional(v.string()),
      env: v.optional(v.record(v.string(), v.string())),
      url: v.optional(v.string()),
      status: v.optional(
        v.union(v.literal("running"), v.literal("stopped"), v.literal("error")),
      ),
    }),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const existingMCP = await ctx.db
      .query("mcps")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("_id"), args.mcpId))
      .first();

    if (!existingMCP) {
      throw new Error("MCP not found");
    }

    await ctx.db.patch(args.mcpId, {
      ...args.updates,
      updatedAt: Date.now(),
    });

    return null;
  },
});

export const remove = mutation({
  args: {
    mcpId: v.id("mcps"),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const existingMCP = await ctx.db
      .query("mcps")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("_id"), args.mcpId))
      .first();

    if (!existingMCP) {
      throw new Error("MCP not found");
    }

    await ctx.db.delete(args.mcpId);

    return null;
  },
});

./routes/documents.ts:
import { query, mutation } from "../_generated/server";
import { v } from "convex/values";
import { requireAuth } from "../utils/helpers";
import { paginationOptsValidator } from "convex/server";

export const get = query({
  args: {
    documentId: v.id("documents"),
  },
  handler: async (ctx, args) => {
    const user = await requireAuth(ctx);

    const source = await ctx.db
      .query("documents")
      .withIndex("by_id", (q) => q.eq("_id", args.documentId))
      .first();
    if (!source) {
      throw new Error("Source not found");
    }

    if (source.userId !== user.userId) {
      throw new Error("Unauthorized");
    }

    return source;
  },
});

export const getAll = query({
  args: {
    paginationOpts: paginationOptsValidator,
  },
  handler: async (ctx, args) => {
    const user = await requireAuth(ctx);

    const documents = await ctx.db
      .query("documents")
      .withIndex("by_user", (q) => q.eq("userId", user.userId))
      .paginate(args.paginationOpts);

    return documents;
  },
});

export const getMultiple = query({
  args: {
    documentIds: v.array(v.id("documents")),
  },
  handler: async (ctx, args) => {
    const user = await requireAuth(ctx);

    const sources = await Promise.all(
      args.documentIds.map(async (documentId) => {
        const source = await ctx.db
          .query("documents")
          .withIndex("by_id", (q) => q.eq("_id", documentId))
          .first();
        if (!source) {
          throw new Error("Source not found");
        }

        if (source.userId !== user.userId) {
          throw new Error("Unauthorized");
        }
        return source;
      }),
    );

    return sources;
  },
});

export const getByKey = query({
  args: {
    key: v.union(v.id("_storage"), v.string()),
  },
  handler: async (ctx, args) => {
    const user = await requireAuth(ctx);

    const source = await ctx.db
      .query("documents")
      .withIndex("by_key", (q) => q.eq("key", args.key))
      .first();
    if (!source) {
      throw new Error("Source not found");
    }

    if (source.userId !== user.userId) {
      throw new Error("Unauthorized");
    }

    return source;
  },
});

export const create = mutation({
  args: {
    name: v.string(),
    type: v.union(
      v.literal("file"),
      v.literal("url"),
      v.literal("site"),
      v.id("documents"),
      v.literal("youtube"),
    ),
    size: v.number(),
    key: v.union(v.id("_storage"), v.string()),
  },
  handler: async (ctx, args) => {
    const user = await requireAuth(ctx);

    const source = await ctx.db.insert("documents", {
      name: args.name,
      type: args.type,
      size: args.size,
      key: args.key,
      userId: user.userId,
    });

    return source;
  },
});

export const remove = mutation({
  args: {
    documentId: v.id("documents"),
  },
  handler: async (ctx, args) => {
    const user = await requireAuth(ctx);

    const source = await ctx.db
      .query("documents")
      .withIndex("by_id", (q) => q.eq("_id", args.documentId))
      .first();
    if (!source) {
      throw new Error("Source not found");
    }

    if (source.userId !== user.userId) {
      throw new Error("Unauthorized");
    }

    await ctx.db.delete(args.documentId);

    return true;
  },
});

export const generateUploadUrl = mutation({
  args: {},
  handler: async (ctx) => {
    await requireAuth(ctx);
    return await ctx.storage.generateUploadUrl();
  },
});

export const generateDownloadUrl = mutation({
  args: {
    storageId: v.id("_storage"),
  },
  handler: async (ctx, args) => {
    await requireAuth(ctx);
    return await ctx.storage.getUrl(args.storageId);
  },
});

./routes/chats.ts:
import { query, mutation } from "../_generated/server";
import { v } from "convex/values";
import { persistentTextStreaming, requireAuth } from "../utils/helpers";
import { paginationOptsValidator } from "convex/server";
import { type StreamId, StreamIdValidator } from "@convex-dev/persistent-text-streaming";
import { api } from "convex/_generated/api";

export const get = query({
  args: {
    chatId: v.id("chats"),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const chat = await ctx.db
      .query("chats")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("_id"), args.chatId))
      .first();

    if (!chat) {
      throw new Error("Chat not found");
    }

    return chat;
  },
});

export const getAll = query({
  args: {
    pinned: v.optional(v.boolean()),
    paginationOpts: v.optional(paginationOptsValidator),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const userChats = await ctx.db
      .query("chats")
      .withIndex("by_user_updated", (q) => q.eq("userId", userId))
      .filter((q) =>
        args.pinned === undefined ? true : q.eq(q.field("pinned"), args.pinned),
      )
      .order("desc")
      .paginate(args.paginationOpts ?? { numItems: 10, cursor: null });

    return userChats;
  },
});

export const getMultiple = query({
  args: {
    chatIds: v.array(v.id("chats")),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    return await Promise.all(
      args.chatIds.map(async (chatId) => {
        const chat = await ctx.db
          .query("chats")
          .withIndex("by_user", (q) => q.eq("userId", userId))
          .filter((q) => q.eq(q.field("_id"), chatId))
          .first();

        if (!chat) {
          throw new Error("Chat not found");
        }

        return chat;
      }),
    );
  },
});

export const create = mutation({
  args: {
    name: v.string(),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const newChatId = await ctx.db.insert("chats", {
      name: args.name,
      userId: userId,
      pinned: false,
      updatedAt: Date.now(),
    });
    return newChatId;
  },
});

export const update = mutation({
  args: {
    chatId: v.id("chats"),
    updates: v.object({
      name: v.optional(v.string()),
      pinned: v.optional(v.boolean()),
    }),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);
    const { chatId, updates } = args;

    if (Object.keys(updates).length === 0) {
      // No actual updates provided
      return null;
    }

    const existingChat = await ctx.db
      .query("chats")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("_id"), chatId))
      .first();

    if (!existingChat) {
      throw new Error("Chat not found");
    }

    await ctx.db.patch(existingChat._id, { ...updates, updatedAt: Date.now() });
    return null;
  },
});

export const remove = mutation({
  args: {
    chatId: v.id("chats"),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const existingChat = await ctx.db
      .query("chats")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("_id"), args.chatId))
      .first();

    if (!existingChat) {
      throw new Error("Chat not found");
    }

    await ctx.db.delete(args.chatId);

    return null;
  },
});

export const send = mutation({
  args: {
    chatId: v.id("chats"),
  },
  handler: async (ctx, args) => {
    await requireAuth(ctx);

    const streamId = await persistentTextStreaming.createStream(ctx);
    await ctx.runMutation(api.routes.chatInput.update, {
      chatId: args.chatId,
        updates: {
          streamId: streamId,
        },
      });

    return streamId;
  },
});

export const getChatBody = query({
  args: {
    streamId: StreamIdValidator,
  },
  handler: async (ctx, args) => {
    await requireAuth(ctx);

    return await persistentTextStreaming.getStreamBody(ctx, args.streamId as StreamId);
  },
});
./routes/projects.ts:
import { query, mutation } from "../_generated/server";
import { v } from "convex/values";
import { requireAuth } from "../utils/helpers";
import { paginationOptsValidator } from "convex/server";

export const get = query({
  args: {
    projectId: v.id("projects"),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const project = await ctx.db
      .query("projects")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("_id"), args.projectId))
      .first();

    if (!project) {
      throw new Error("Project not found");
    }

    return project;
  },
});

export const getAll = query({
  args: {
    paginationOpts: paginationOptsValidator,
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const projects = await ctx.db
      .query("projects")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .order("desc")
      .paginate(args.paginationOpts);

    return projects;
  },
});

export const getMultiple = query({
  args: {
    projectIds: v.array(v.id("projects")),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const projects = await Promise.all(
      args.projectIds.map(async (projectId) => {
        const project = await ctx.db
          .query("projects")
          .withIndex("by_user", (q) => q.eq("userId", userId))
          .filter((q) => q.eq(q.field("_id"), projectId))
          .first();

        if (!project) {
          throw new Error("Project not found");
        }

        return project;
      }),
    );

    return projects;
  },
});

export const create = mutation({
  args: {
    name: v.string(),
    description: v.optional(v.string()),
    systemPrompt: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const newProjectId = await ctx.db.insert("projects", {
      name: args.name,
      description: args.description,
      systemPrompt: args.systemPrompt,
      userId: userId,
      updatedAt: Date.now(),
    });

    const newProject = await ctx.db.get(newProjectId);

    if (!newProject) {
      throw new Error("Project not found");
    }

    return newProject;
  },
});

export const update = mutation({
  args: {
    projectId: v.id("projects"),
    updates: v.object({
      name: v.optional(v.string()),
      description: v.optional(v.string()),
      systemPrompt: v.optional(v.string()),
    }),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const existingProject = await ctx.db
      .query("projects")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("_id"), args.projectId))
      .first();

    if (!existingProject) {
      throw new Error("Project not found");
    }

    await ctx.db.patch(existingProject._id, {
      ...args.updates,
      updatedAt: Date.now(),
    });

    return true;
  },
});

export const remove = mutation({
  args: {
    projectId: v.id("projects"),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const existingProject = await ctx.db
      .query("projects")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("_id"), args.projectId))
      .first();

    if (!existingProject) {
      throw new Error("Project not found");
    }

    await ctx.db.delete(args.projectId);

    return true;
  },
});

./routes/chatInput.ts:
import { query, mutation, internalQuery } from "../_generated/server";
import { v } from "convex/values";
import { requireAuth } from "../utils/helpers";
import { StreamIdValidator } from "@convex-dev/persistent-text-streaming";
import { api } from "convex/_generated/api";
import type { Doc, Id } from "convex/_generated/dataModel";

export const get = query({
  args: {
    chatId: v.union(v.id("chats"), v.literal("new")),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const chatInput = await ctx.db
      .query("chatInput")
      .withIndex("by_user_chat", (q) =>
        q.eq("chatId", args.chatId).eq("userId", userId),
      )
      .first();
    if (!chatInput && args.chatId !== "new") {
      throw new Error("Chat input not found");
    }

    // Get chat
    const chat = await ctx.db
      .query("chats")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("_id"), args.chatId))
      .first();

    if (!chat && args.chatId !== "new") {
      throw new Error("Chat not found");
    }

    return {
      ...chatInput,
      chat,
    };
  },
});

export const getByStreamId = internalQuery({
  args: {
    streamId: StreamIdValidator,
  },
  handler: async (ctx, args): Promise<{
    chatInput: Doc<"chatInput">;
    chat: Doc<"chats">;
  }> => {
    const chatInput = await ctx.db
      .query("chatInput")
      .withIndex("by_stream", (q) =>
        q.eq("streamId", args.streamId),
      )
      .first();

    if (!chatInput) {
      throw new Error("Chat input not found");
    }

    const chat = await ctx.db
      .query("chats")
      .withIndex("by_user", (q) => q.eq("userId", chatInput.userId))
      .filter((q) => q.eq(q.field("_id"), chatInput.chatId))
      .first();

    if (!chat) {
      throw new Error("Chat not found");
    }

    return {
      chatInput,
      chat,
    };
  },
});

export const create = mutation({
  args: {
    chatId: v.union(v.id("chats"), v.literal("new")),
    documents: v.optional(v.array(v.id("documents"))),
    text: v.optional(v.string()),
    streamId: v.optional(StreamIdValidator),
    projectId: v.optional(v.id("projects")),
    model: v.optional(v.string()),
    agentMode: v.optional(v.boolean()),
    smortMode: v.optional(v.boolean()),
    webSearch: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    // Check if chatInput already exists
    const existingChatInput = await ctx.db
      .query("chatInput")
      .withIndex("by_user_chat", (q) =>
        q.eq("chatId", args.chatId).eq("userId", userId),
      )
      .first();

    if (existingChatInput && args.chatId !== "new") {
      throw new Error("Chat input already exists");
    }

    // Check if chat exists
    const chat = await ctx.db
      .query("chats")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("_id"), args.chatId))
      .first();

    if (!chat && args.chatId !== "new") {
      throw new Error("Chat not found");
    }

    const newChatInputId = await ctx.db.insert("chatInput", {
      chatId: args.chatId,
      userId,
      documents: args.documents,
      text: args.text,
      streamId: args.streamId,
      projectId: args.projectId,
      model: args.model,
      agentMode: args.agentMode,
      smortMode: args.smortMode,
      webSearch: args.webSearch,
      updatedAt: Date.now(),
    });
    const newChatInput = await ctx.db.get(newChatInputId);

    if (!newChatInput) {
      throw new Error("Chat input not found");
    }

    return {
      ...newChatInput,
      chat,
    };
  },
});

export const update = mutation({
  args: {
    chatId: v.union(v.id("chats"), v.literal("new")),
    updates: v.object({
      documents: v.optional(v.array(v.id("documents"))),
      text: v.optional(v.string()),
      streamId: v.optional(StreamIdValidator),
      projectId: v.optional(v.id("projects")),
      model: v.optional(v.string()),
      agentMode: v.optional(v.boolean()),
      smortMode: v.optional(v.boolean()),
      webSearch: v.optional(v.boolean()),
    }),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    let existingChatInput = await ctx.db
      .query("chatInput")
      .withIndex("by_user_chat", (q) =>
        q.eq("chatId", args.chatId).eq("userId", userId),
      )
      .first();

    if (!existingChatInput) {
      throw new Error("Chat input not found");
    }

    // Check if chat exists
    const chat = await ctx.db
      .query("chats")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("_id"), args.chatId))
      .first();

    if (!chat && args.chatId !== "new") {
      throw new Error("Chat not found");
    }

    await ctx.db.patch(existingChatInput._id, {
      ...args.updates,
      updatedAt: Date.now(),
    });

    return true;
  },
});

export const remove = mutation({
  args: {
    chatId: v.union(v.id("chats"), v.literal("new")),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuth(ctx);

    const existingChatInput = await ctx.db
      .query("chatInput")
      .withIndex("by_user_chat", (q) =>
        q.eq("chatId", args.chatId).eq("userId", userId),
      )
      .first();

    if (!existingChatInput || args.chatId === "new") {
      throw new Error("Chat input not found");
    }

    // Check if chat exists
    const chat = await ctx.db
      .query("chats")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .filter((q) => q.eq(q.field("_id"), args.chatId))
      .first();

    if (!chat && args.chatId !== "new") {
      throw new Error("Chat not found");
    }

    await ctx.db.delete(existingChatInput._id);

    return true;
  },
});

./test.txt:

./schema.ts:
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
import { authTables } from "@convex-dev/auth/server";
import { StreamIdValidator } from "@convex-dev/persistent-text-streaming";

export default defineSchema({
  ...authTables,
  documents: defineTable({
    name: v.string(),
    type: v.union(
      v.literal("file"),
      v.literal("url"),
      v.literal("site"),
      v.id("documents"),
      v.literal("youtube"),
    ),
    size: v.number(),
    key: v.union(v.id("_storage"), v.string()),
    userId: v.id("users"),
  })
    .index("by_key", ["key"])
    .index("by_user", ["userId"]),
  chats: defineTable({
    name: v.string(),
    userId: v.id("users"),
    pinned: v.boolean(),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_user_updated", ["userId", "updatedAt"]),
  chatInput: defineTable({
    chatId: v.union(v.id("chats"), v.literal("new")),
    userId: v.id("users"),
    documents: v.optional(v.array(v.id("documents"))),
    text: v.optional(v.string()),
    streamId: v.optional(StreamIdValidator),
    projectId: v.optional(v.id("projects")),
    model: v.optional(v.string()),
    agentMode: v.optional(v.boolean()),
    smortMode: v.optional(v.boolean()),
    webSearch: v.optional(v.boolean()),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_user_chat", ["chatId", "userId"])
    .index("by_stream", ["streamId"]),
  projects: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    systemPrompt: v.optional(v.string()),
    userId: v.id("users"),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_user_updated", ["userId", "updatedAt"]),
  projectDocuments: defineTable({
    projectId: v.id("projects"),
    documentId: v.id("documents"),
    selected: v.boolean(),
    updatedAt: v.number(),
  })
    .index("by_project", ["projectId"])
    .index("by_project_document", ["projectId", "documentId"]),
  mcps: defineTable({
    name: v.string(),
    command: v.optional(v.string()),
    env: v.optional(v.record(v.string(), v.string())),
    url: v.optional(v.string()),
    status: v.optional(
      v.union(v.literal("running"), v.literal("stopped"), v.literal("error")),
    ),
    userId: v.id("users"),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_user_updated", ["userId", "updatedAt"])
    .index("by_user_created", ["userId", "createdAt"])
    .index("by_status", ["status"]),
});

./auth.ts:
import { convexAuth } from "@convex-dev/auth/server";
import { Anonymous } from "@convex-dev/auth/providers/Anonymous";
import GitHub from "@auth/core/providers/github";
import Google from "@auth/core/providers/google";
import Slack from "@auth/core/providers/slack";
import { query } from "./_generated/server";
import { v } from "convex/values";

export const { auth, signIn, signOut, store, isAuthenticated } = convexAuth({
  providers: [
    Anonymous,
    ...(process.env.AUTH_GITHUB_SECRET && process.env.AUTH_GITHUB_ID
      ? [GitHub]
      : []),
    ...(process.env.AUTH_GOOGLE_SECRET && process.env.AUTH_GOOGLE_ID
      ? [Google]
      : []),
    ...(process.env.AUTH_SLACK_SECRET && process.env.AUTH_SLACK_ID
      ? [Slack]
      : []),
  ],
  callbacks: {
    async afterUserCreatedOrUpdated(ctx, args) {
      // Create a new chat for the user
      await ctx.db.insert("chatInput", {
        chatId: "new",
        userId: args.userId,
        updatedAt: Date.now(),
        agentMode: false,
        smortMode: false,
        webSearch: false,
      });
    },
  },
});

export const isProviderEnabled = query({
  args: {
    provider: v.union(
      v.literal("github"),
      v.literal("google"),
      v.literal("slack"),
    ),
  },
  handler: async (_, args) => {
    if (args.provider === "github") {
      return process.env.AUTH_GITHUB_SECRET && process.env.AUTH_GITHUB_ID;
    }
    if (args.provider === "google") {
      return process.env.AUTH_GOOGLE_SECRET && process.env.AUTH_GOOGLE_ID;
    }
    if (args.provider === "slack") {
      return process.env.AUTH_SLACK_SECRET && process.env.AUTH_SLACK_ID;
    }
    return false;
  },
});

./http.ts:
import { httpRouter } from "convex/server";
import { corsRouter } from "convex-helpers/server/cors";
import { auth } from "./auth";
import { chat } from "./http/chat";

const http = httpRouter();
const cors = corsRouter(http, {
  allowedHeaders: ["*"],
  allowedOrigins: ["http://localhost:3000"]
});

auth.addHttpRoutes(http);

cors.route({
  path: "/chat",
  method: "POST",
  handler: chat,
});

export default http;

./crons.ts:
import { cronJobs } from "convex/server";
import { api } from "./_generated/api";

const crons = cronJobs();

crons.interval(
  "stopIdle",
  { minutes: 15 }, // every minute
  api.actions.mcps.stopIdle,
);

export default crons;

./convex.config.ts:
import { defineApp } from "convex/server";
import persistentTextStreaming from "@convex-dev/persistent-text-streaming/convex.config";

const app = defineApp();
app.use(persistentTextStreaming);

export default app;

./auth.config.ts:
export default {
  providers: [
    {
      domain: process.env.CONVEX_SITE_URL,
      applicationID: "convex",
    },
  ],
};

